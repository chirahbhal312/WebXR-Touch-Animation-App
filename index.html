<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>AR Cube with Drawing Gestures</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>body { margin:0; overflow:hidden; }</style>
  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/examples/jsm/webxr/ARButton.js": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/webxr/ARButton.js"
      }
    }
  </script>
</head>
<body>
<script type="module">
import * as THREE from 'three';
import { ARButton } from 'three/examples/jsm/webxr/ARButton.js';

let scene, camera, renderer, controller;
let cube = null, cubePlaced = false;
let selectedObject = null;
let isDragging = false, dragPlane = new THREE.Plane(), dragOffset = new THREE.Vector3(), dragIntersection = new THREE.Vector3();
let initialDist = 0, initialScale = 1, rotationStartAngle = 0, initialRotY = 0;
const raycaster = new THREE.Raycaster();

// Init AR scene
scene = new THREE.Scene();
camera = new THREE.PerspectiveCamera();
renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.xr.enabled = true;
document.body.appendChild(renderer.domElement);
document.body.appendChild(ARButton.createButton(renderer, { requiredFeatures:['hit-test'] }));

// Lighting
scene.add(new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1));

// Controller to tap-place cube
controller = renderer.xr.getController(0);
controller.addEventListener('select', () => {
  if (cubePlaced) return;
  const size = 0.1;
  const geo = new THREE.BoxGeometry(size, size, size);
  const mat = new THREE.MeshStandardMaterial({ color:0x00ff00 });
  cube = new THREE.Mesh(geo, mat);
  scene.add(cube);

  // Position cube 1.5m in front
  const dir = new THREE.Vector3();
  camera.getWorldDirection(dir);
  cube.position.copy(camera.position).add(dir.multiplyScalar(1.5));
  cubePlaced = true;
  selectedObject = cube;
});
scene.add(controller);

// Interaction: touch gestures
window.addEventListener('touchstart', e => {
  if (!cubePlaced) return;
  const touch = e.touches[0];

  if (e.touches.length === 1) {
    isDragging = true;
    const ndc = new THREE.Vector2(
      (touch.clientX/window.innerWidth)*2 -1,
      -(touch.clientY/window.innerHeight)*2 +1
    );
    raycaster.setFromCamera(ndc, camera);
    dragPlane.setFromNormalAndCoplanarPoint(
      camera.getWorldDirection(new THREE.Vector3()).normalize(),
      cube.position
    );
    raycaster.ray.intersectPlane(dragPlane, dragIntersection);
    dragOffset.copy(dragIntersection).sub(cube.position);
  }
  else if (e.touches.length === 2) {
    const dx = e.touches[0].clientX - e.touches[1].clientX;
    const dy = e.touches[0].clientY - e.touches[1].clientY;
    initialDist = Math.hypot(dx, dy);
    initialScale = cube.scale.x;
    rotationStartAngle = Math.atan2(dy, dx);
    initialRotY = cube.rotation.y;
  }
});

window.addEventListener('touchmove', e => {
  if (!cubePlaced) return;
  if (e.touches.length === 1 && isDragging) {
    const touch = e.touches[0];
    const ndc = new THREE.Vector2(
      (touch.clientX/window.innerWidth)*2 -1,
      -(touch.clientY/window.innerHeight)*2 +1
    );
    raycaster.setFromCamera(ndc, camera);
    raycaster.ray.intersectPlane(dragPlane, dragIntersection);
    cube.position.copy(dragIntersection.sub(dragOffset));
  }
  else if (e.touches.length === 2) {
    const dx = e.touches[0].clientX - e.touches[1].clientX;
    const dy = e.touches[0].clientY - e.touches[1].clientY;
    const newDist = Math.hypot(dx, dy);
    const scale = initialScale * (newDist / initialDist);
    cube.scale.setScalar(scale);
    const angle = Math.atan2(dy, dx);
    cube.rotation.y = initialRotY + (angle - rotationStartAngle);
  }
}, { passive:false });

window.addEventListener('touchend', e => {
  isDragging = false;
});

// Render loop
renderer.setAnimationLoop(() => {
  renderer.render(scene, camera);
});

// Resize
window.addEventListener('resize', () => {
  renderer.setSize(window.innerWidth, window.innerHeight);
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
});
</script>
</body>
</html>
