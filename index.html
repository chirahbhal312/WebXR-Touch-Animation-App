<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>AR Viewer + Touch Gestures</title>
  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.module.js",
        "three/examples/jsm/loaders/GLTFLoader": "https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/loaders/GLTFLoader.js",
        "three/examples/jsm/loaders/FBXLoader": "https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/loaders/FBXLoader.js",
        "three/examples/jsm/controls/OrbitControls": "https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/controls/OrbitControls.js",
        "three/examples/jsm/webxr/ARButton": "https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/webxr/ARButton.js"
      }
    }
  </script>
  <style>
    body { margin:0; overflow:hidden; touch-action:none; }
    canvas { touch-action:none; }
    #infoPanel {
      position:absolute; top:0; right:0;
      width:300px; height:100%; overflow:auto;
      background:#111; color:#eee; padding:15px;
      font-family:sans-serif; font-size:14px; z-index:10;
    }
    #meshButtons button {
      display:block; width:100%; margin:5px 0;
      background:#333; color:#fff; border:none; padding:8px;
    }
    #meshButtons button:hover { background:#555; }
  </style>
</head>
<body>
  <input id="modelInput" type="file" accept=".glb,.gltf,.fbx"
    style="position:absolute; top:10px; left:10px; z-index:10;">
  <div id="infoPanel">
    <h3>Animations</h3><div id="meshButtons">Load a model...</div>
    <h3>All Animation Names</h3><pre id="animations"></pre>
    <h3>Audios</h3><pre id="audios"></pre>
    <h3>Selected Mesh</h3><div id="selectedMesh">None</div>
  </div>
  
  <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader';
    import { FBXLoader } from 'three/examples/jsm/loaders/FBXLoader';
    import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';
    import { ARButton } from 'three/examples/jsm/webxr/ARButton';
    
    // Scene setup
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.01, 100);
    camera.position.set(2,2,4);
    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.xr.enabled = true;
    document.body.appendChild(renderer.domElement);
    document.body.appendChild(ARButton.createButton(renderer, { requiredFeatures:['hit-test'] }));
    
    const controls = new OrbitControls(camera, renderer.domElement);
    renderer.xr.addEventListener('sessionstart', ()=>controls.enabled = false);
    renderer.xr.addEventListener('sessionend', ()=>controls.enabled = true);
    
    scene.add(new THREE.AmbientLight(0xffffff,1));
    const listener = new THREE.AudioListener();
    camera.add(listener);
    
    // Loaders
    const gltfLoader = new GLTFLoader(), fbxLoader = new FBXLoader();
    const input = document.getElementById('modelInput');
    const meshButtons = document.getElementById('meshButtons');
    const animationsPanel = document.getElementById('animations');
    const audiosPanel = document.getElementById('audios');
    const selectedMeshPanel = document.getElementById('selectedMesh');
    
    let mixer = null, clock = new THREE.Clock();
    let meshList = [], audioList = [], animationList = [];
    let reticle, hitTestSource=null, hitRequested=false;
    let placedModel = null, modelPlaced = false;
    
    // Gesture state
    let initialPinchDist = null, baseScale = 1;
    let dragging = false, dragStart = null, longPress = false, longTimeout = null;
    
    // Reticle for placement
    reticle = new THREE.Mesh(
      new THREE.RingGeometry(0.05,0.08,32).rotateX(-Math.PI/2),
      new THREE.MeshBasicMaterial({ color:0x00ff00 })
    );
    reticle.matrixAutoUpdate = false;
    reticle.visible = false;
    scene.add(reticle);
    
    function processModel(model, demos=[]) {
      if (placedModel) scene.remove(placedModel);
      placedModel = model;
      meshList = []; audioList = []; animationList = demos;
      
      model.traverse(c => { if(c.isMesh) meshList.push(c); if(c.type==='Audio') audioList.push(c); });
      const box = new THREE.Box3().setFromObject(model);
      const center = box.getCenter(new THREE.Vector3());
      model.position.sub(center);
      const size = box.getSize(new THREE.Vector3());
      const maxD = Math.max(...Object.values(size));
      baseScale = placedModel.scale.x = (maxD > 0.6 ? 0.6 / maxD : 1);
      
      mixer = demos.length ? new THREE.AnimationMixer(model) : null;
      
      meshButtons.innerHTML = "";
      demos.forEach((clip,i)=>{
        const btn = document.createElement('button');
        btn.textContent = clip.name || `Anim ${i+1}`;
        btn.onclick = ()=>{ mixer.stopAllAction(); mixer.clipAction(clip).reset().play(); };
        meshButtons.appendChild(btn);
      });
      animationsPanel.textContent = JSON.stringify(demos.map(c=>c.name),null,2);
      audiosPanel.textContent = JSON.stringify(audioList.map((_,i)=>`Audio ${i}`),null,2);
      selectedMeshPanel.textContent = 'None';
    }
    
    input.onchange = e => {
      const file = input.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = ev => {
        const buf = ev.target.result;
        if (file.name.toLowerCase().endsWith('.fbx')) {
          processModel(fbxLoader.parse(buf,''), []);
        } else {
          gltfLoader.parse(buf, '', gl => processModel(gl.scene, gl.animations));
        }
      };
      reader.readAsArrayBuffer(file);
    };
    
    // Touch handling
    renderer.domElement.addEventListener('touchstart', e => {
      if (!modelPlaced) return;
      if (e.touches.length === 2) {
        initialPinchDist = Math.hypot(
          e.touches[0].pageX - e.touches[1].pageX,
          e.touches[0].pageY - e.touches[1].pageY);
      } else if (e.touches.length === 1) {
        dragStart = { x: e.touches[0].pageX, y: e.touches[0].pageY };
        longTimeout = setTimeout(() => longPress = true, 500);
      }
    });
    
    renderer.domElement.addEventListener('touchmove', e => {
      if (!modelPlaced) return;
      e.preventDefault();
      if (e.touches.length === 2 && initialPinchDist) {
        const d = Math.hypot(
          e.touches[0].pageX - e.touches[1].pageX,
          e.touches[0].pageY - e.touches[1].pageY);
        placedModel.scale.setScalar(baseScale * (d / initialPinchDist));
      } else if (e.touches.length === 1 && dragStart) {
        clearTimeout(longTimeout);
        const dx = (e.touches[0].pageX - dragStart.x) / 200;
        if (longPress) {
          placedModel.position.x += dx;
          placedModel.position.z += (e.touches[0].pageY - dragStart.y) / 200;
        } else {
          placedModel.rotation.y -= dx;
        }
        dragStart = { x: e.touches[0].pageX, y: e.touches[0].pageY };
      }
    }, { passive: false });
    
    renderer.domElement.addEventListener('touchend', () => {
      clearTimeout(longTimeout);
      baseScale = placedModel.scale.x;
      initialPinchDist = null; longPress = false;
    });
    
    // Raycasting for animations
    const raycaster = new THREE.Raycaster(), mouse = new THREE.Vector2();
    window.addEventListener('click', e => {
      if (!modelPlaced) return;
      mouse.x = (e.clientX/window.innerWidth)*2 -1;
      mouse.y = -(e.clientY/window.innerHeight)*2 +1;
      raycaster.setFromCamera(mouse, camera);
      const hit = raycaster.intersectObjects(meshList, true)[0];
      if (hit) {
        selectedMeshPanel.textContent = hit.object.name || 'Unnamed';
        const idx = meshList.indexOf(hit.object);
        if (idx>=0 && audioList[idx]) audioList[idx].play();
        if (mixer && hit.object.name) {
          const clip = animationList.find(c=>c.name===hit.object.name);
          if (clip) { mixer.stopAllAction(); mixer.clipAction(clip).reset().play(); }
        }
      }
    });
    
    // AR controller + reticle + hit-testing
    const controller = renderer.xr.getController(0);
    controller.addEventListener('select', () => {
      if (!modelPlaced && reticle.visible && placedModel) {
        placedModel.position.setFromMatrixPosition(reticle.matrix);
        scene.add(placedModel); modelPlaced = true;
        reticle.visible = false;
        hitRequested = true;
        hitTestSource = null;
      } else if (modelPlaced) {
        raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
        raycaster.ray.direction.set(0,0,-1).transformDirection(controller.matrixWorld);
        const hit = raycaster.intersectObjects(meshList,true)[0];
        if (hit) { selectedMeshPanel.textContent = hit.object.name; }
      }
    });
    scene.add(controller);
    
    renderer.setAnimationLoop((time, frame) => {
      if (mixer) mixer.update(clock.getDelta());
      if (frame && !modelPlaced) {
        const sess = renderer.xr.getSession();
        if (!hitRequested) {
          sess.requestReferenceSpace('viewer').then(ref =>
            sess.requestHitTestSource({space:ref}).then(src => hitTestSource = src)
          );
          sess.addEventListener('end', () => { hitRequested=false; modelPlaced=false; hitTestSource=null; });
          hitRequested = true;
        }
        if (hitTestSource) {
          const hits = frame.getHitTestResults(hitTestSource);
          if (hits.length) {
            const pose = hits[0].getPose(renderer.xr.getReferenceSpace());
            reticle.visible = true;
            reticle.matrix.fromArray(pose.transform.matrix);
          } else {
            reticle.visible = false;
          }
        }
      }
      renderer.render(scene, camera);
    });
    
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
